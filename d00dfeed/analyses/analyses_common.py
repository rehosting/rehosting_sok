import os, argparse, json, operator, logging
import matplotlib.pyplot as plt
import numpy as np
import statistics as stats

########################################################################################################################
# FILE INPUT (JSON)
########################################################################################################################

def argparse_and_get_files(desc_str):

    '''
    Common argument parser for graphing scripts
    '''

    arg_parser = argparse.ArgumentParser(description=desc_str)
    arg_parser.add_argument(
            'json_dir',
            type=str,
            help="Directory containing multiple JSON files (output from \'df_analyze.py\')."
    )

    args = arg_parser.parse_args()
    assert(os.path.isdir(args.json_dir))
    json_files = [os.path.join(args.json_dir, file) for file in os.listdir(args.json_dir) if file.endswith(".json")]
    assert(len(json_files) > 0)

    return json_files

########################################################################################################################
# FILE OUTPUT (PYTHON)
########################################################################################################################

def write_hdr_for_py_file(file_name, hdr_str):

    '''
    Write a header for an autogenerated file, overwites existing.
    '''

    with open(file_name, "w") as f:
        f.write("#! /usr/bin/python3")
        f.write("\n\n")
        f.write("#" * 120 + "\n")
        f.write("# %s\n" % hdr_str)
        f.write("#" * 120 + "\n")

def write_list_helper(file_ptr, var_list, indent_lvl = 1, trailing_comma = False):

    '''
    Write helper for file generation
    '''

    file_ptr.write("[\n")

    last_idx = (len(var_list) - 1)
    for idx, val in enumerate(var_list):

        if not (idx % 5):
            file_ptr.write("\n" + ("\t" * indent_lvl))

        if isinstance(val, str):
            file_ptr.write("\'%s\'" % val)
        else:
            file_ptr.write("{}".format(val))

        if idx != last_idx:
            file_ptr.write(",")

    file_ptr.write("\n\n" + ("\t" * (indent_lvl - 1)) + "]")
    if trailing_comma:
        file_ptr.write(",")

def write_list_to_py_file(file_name, var_name, var_list, indent_lvl = 1):

    '''
    Write a list to an autogenerated file, appends to existing.
    '''

    with open(file_name, "a") as f:

        f.write("\n\n")
        f.write("%s = " % var_name)
        write_list_helper(f, var_list, indent_lvl)


def write_dict_to_py_file(file_name, var_name, var_dict, indent_lvl = 1):

    '''
    Write a dict to an autogenerated file, appends to existing.
    '''

    with open(file_name, "a") as f:
        f.write("\n\n")
        f.write("%s = {\n" % var_name)

        for key, val in var_dict.items():

            last_entry = (key == list(var_dict.keys())[-1])
            f.write(("\t" * indent_lvl))

            if isinstance(key, str):
                f.write("\n" + ("\t" * indent_lvl) + "\'%s\' : " % key)
            else:
                f.write("\n" + ("\t" * indent_lvl) + "{} : ".format(key))

            if isinstance(val, list) or isinstance(val, set):
                write_list_helper(f, val, (indent_lvl + 1), (not last_entry))
            else:
                if isinstance(val, str):
                    f.write("\'{}\'".format(val))
                else:
                    f.write("{}".format(val))
                if not last_entry:
                    f.write(",")

        f.write("\n\n}")

########################################################################################################################
# COLLECTION HELPERS
########################################################################################################################

# TODO: switch some of this over to defaultdict for cleaner key addition code

def build_dict_two_lvl_cnt(json_files, lvl_1_key, lvl_2_key):

    '''
    Build a dict of dicts from all JSON files: {lvl_1_val : {lvl_2_val : lvl_2_val_cnt}}
    '''

    two_lvl_dict = {}

    for json_path in json_files:
        with open(json_path) as json_file:
            data = json.load(json_file)

        try:
            # Build level 1: {lvl_1_val : None}
            lvl_1_val = data[lvl_1_key]
            if lvl_1_val not in two_lvl_dict:
                two_lvl_dict[lvl_1_val] = {}

            # Build level 2: {lvl_1_val : {lvl_2_val : lvl_2_val_cnt}}
            for lvl_2_val in data[lvl_2_key]:
                if lvl_2_val not in two_lvl_dict[lvl_1_val]:
                    two_lvl_dict[lvl_1_val][lvl_2_val] = 1
                else:
                    two_lvl_dict[lvl_1_val][lvl_2_val] += 1
        except:
            logging.warn("Skipping non-DTB file: %s" % json_path)

    return two_lvl_dict

def build_dict_one_lvl_cnt(json_files, lvl_1_key):

    '''
    Build a dict from all JSON: {lvl_1_val : lvl_1_val_cnt}
    '''

    one_lvl_dict = {}

    for json_path in json_files:
        with open(json_path) as json_file:
            data = json.load(json_file)

        try:
            # Build level 1: {lvl_1_val : lvl_1_val_cnt}
            lvl_1_val = data[lvl_1_key]
            if lvl_1_val not in one_lvl_dict:
                one_lvl_dict[lvl_1_val] = 1
            else:
                one_lvl_dict[lvl_1_val] += 1
        except:
            logging.warn("Skipping non-DTB file: %s" % json_path)

    return one_lvl_dict

def build_dict_one_lvl_sum(json_files, lvl_1_key, sum_key):

    '''
    Build a dict from all JSON: {lvl_1_val : sum}
    '''

    one_lvl_dict = {}

    for json_path in json_files:
        with open(json_path) as json_file:
            data = json.load(json_file)

        try:
            # Build level 1: {lvl_1_val : sum}
            lvl_1_val = data[lvl_1_key]
            if lvl_1_val not in one_lvl_dict:
                one_lvl_dict[lvl_1_val] = data[sum_key]
            else:
                one_lvl_dict[lvl_1_val] += data[sum_key]
        except:
            logging.warn("Skipping non-DTB file: %s" % json_path)

    return one_lvl_dict

def build_dict_one_lvl_list(json_files, lvl_1_key, val_key):

    '''
    Build a dict from all JSON: {lvl_1_val : [file_1_val, file_2_val, file_3_val, ... ]}
    '''

    one_lvl_dict = {}

    for json_path in json_files:
        with open(json_path) as json_file:
            data = json.load(json_file)

        try:
            # {lvl_1_val : [file_1_val, file_2_val, file_3_val, ... ]}
            lvl_1_val = data[lvl_1_key]
            if lvl_1_val not in one_lvl_dict:
                one_lvl_dict[lvl_1_val] = [data[val_key]]
            else:
                one_lvl_dict[lvl_1_val].append(data[val_key])
        except:
            logging.warn("Skipping non-DTB file: %s" % json_path)

    return one_lvl_dict

def build_tuple_key_dict(json_files, tup_key_str, tup_val_str):

    tup_key_dict = {}

    for json_path in json_files:
        with open(json_path) as json_file:
            data = json.load(json_file)

        try:
            for entry in data:
                tup_key = tuple(entry[tup_key_str])
                tup_val = entry[tup_val_str]
                tup_key_dict[tup_key] = tup_val
        except:
            logging.warn("Cannot extract tuple-key dict from file: %s" % json_path)

    return tup_key_dict

########################################################################################################################
# LABELING HELPERS
########################################################################################################################

def label_bars_str(bars, ax, str_int_list):

    '''
    Add str bar labels to bar chart
    '''

    for idx, bar in enumerate(bars):
        height = bar.get_height()
        ax.text(
            (bar.get_x() + bar.get_width()/2.0),
            (height + 5),
            ('%s: %d' % (str_int_list[idx][0], int(height))),
            ha='center',
            va='bottom',
            fontsize='medium',
            rotation='vertical'
        )

def label_bars_cnt(bars, ax):

    '''
    Add numerical bar height labels to bar chart
    '''

    for bar in bars:
        height = bar.get_height()
        ax.text(
            (bar.get_x() + bar.get_width()/2.0),
            (height),
            (('%d' if isinstance(height, np.int64) else '%.2f') % height),
            ha='center',
            va='bottom'
        )

########################################################################################################################
# GRAPHS
########################################################################################################################

def graph_simple_bar(x, y, x_label, y_label, title, bar_color='blue', text_fontsize='xx-large'):

    '''
    Bar graph with labeled bars
    '''

    _, ax = plt.subplots()
    plt_bars = ax.bar(x, y, color=bar_color)

    ax.set_ylabel(y_label, fontweight='bold', fontsize=text_fontsize)
    ax.set_xlabel(x_label, fontweight='bold', fontsize=text_fontsize)
    ax.set_title(title, fontweight='bold', fontsize=text_fontsize)
    ax.set_xticklabels(x, fontsize=text_fontsize)
    plt.yticks(fontsize=text_fontsize)

    label_bars_cnt(plt_bars, ax)

def graph_multibar_top_n_items(top_n, two_lvl_cnt_dict, x_label, y_label, title,  text_fontsize='xx-large'):

    '''
    Graph the top n most common items by category (ex. top 10 most common devices by architecture)
    TODO: clean up this logic for ease of readability
    '''

    _, ax = plt.subplots()
    bar_width = (1.0/len(two_lvl_cnt_dict.keys()))
    first_list_toggle = True
    list_offsets = []
    new_list = []

    for idx, lvl_1_key in enumerate(two_lvl_cnt_dict.keys()):

        sorted_items = sorted(two_lvl_cnt_dict[lvl_1_key].items(), key=operator.itemgetter(1), reverse=True)
        top_n_items = sorted_items[:top_n]
        bar_heights = [x[1] for x in top_n_items]

        # Set bar's x-axis pos
        if first_list_toggle:
            new_list = np.arange(len(bar_heights))
            list_offsets.append(new_list)
            first_list_toggle = False
        else:
            new_list = [(x + bar_width) for x in list_offsets[-1]]
            list_offsets.append(new_list)

        plt_bars = ax.bar(new_list, bar_heights, width=bar_width, edgecolor='white', label=lvl_1_key)
        label_bars_str(plt_bars, ax, top_n_items)

    ax.set_ylabel(y_label, fontweight='bold', fontsize=text_fontsize)
    ax.set_xlabel(x_label, fontweight='bold', fontsize=text_fontsize)
    ax.set_title(title, fontweight='bold', fontsize=text_fontsize)

    plt.yticks(fontsize=text_fontsize)
    plt.xticks([(x + bar_width) for x in range(len(bar_heights))], [str(x) for x in range(1, (top_n + 1))], fontsize=text_fontsize)
    plt.legend()

def graph_simple_histogram(data, x_label, y_label, title, text_fontsize='xx-large'):

    '''
    Make a histogram.
    Source: https://realpython.com/python-histograms/
    '''

    n, bins, patches = plt.hist(x=data, bins='auto', alpha=0.7, rwidth=0.85)
    plt.grid(axis='y', alpha=0.75)

    # Apply labels
    plt.xlabel(x_label, fontweight='bold', fontsize=text_fontsize)
    plt.ylabel(y_label, fontweight='bold', fontsize=text_fontsize)
    plt.title(title, fontweight='bold', fontsize=text_fontsize)

    # Set a clean upper y-axis limit.
    maxfreq = n.max()
    plt.ylim(top=np.ceil(maxfreq / 10) * 10 if maxfreq % 10 else maxfreq + 10)

########################################################################################################################
# STATS
########################################################################################################################

def get_mean_median_std_dev(int_list):

    '''
    Get mean, median, standard deviation for input list
    '''

    return stats.mean(int_list), stats.median(int_list), stats.stdev(int_list)

def print_mean_median_std_dev_for_dict_of_lists(dict_of_lists, header_str):

    print(header_str)

    for key in dict_of_lists:

        list_len = len(dict_of_lists[key])

        if  (list_len >= 2): # Need at least 2 data points for stats
            mean, median, std_dev = get_mean_median_std_dev(dict_of_lists[key])
            print("{} : ({}, {}, {})".format(key, mean, median, std_dev))

        elif (list_len == 1):
            single_data_point = dict_of_lists[key][0]
            print("{} : ({}, {}, {})".format(key, single_data_point, single_data_point, 0.0))

        else:
            print("Error: insufficient data for key \'{}\'".format(key))

